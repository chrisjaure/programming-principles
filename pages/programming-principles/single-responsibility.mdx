# Single Responsibility

1. Collect a city name from the user.
2. When the user submits the form, fetch weather data for the city.
3. When the result is received, display it.

## One Component

Below is a single component that meets all of the requirements.

```jsx App.jsx
export default function App() {
  const [city, setCity] = useState('')
  const [weather, setWeather] = useState(null)

  return (
    <div>
      <form onSubmit={async () => {
        const result = await fetch(`getweather?city=${city}`)
        setWeather(await result.json())
      }}>
        <label>
          City:
          <input
            onChange((event) => {
              setName(event.target.value)
            })
            value={name}
          />
        </label>

        <button type="submit">
          Submit
        </button>
      </form>

      {weather ? (
        The weather is {weather}.
      ) : null}
    </div>
  )
}

```

### This approach is good when

- you're building a proof of concept
- you are learning
- the requirements won't change over time
- you have a tight deadline

In fact, most code starts out this way because it's easy to write and understand!
Later on, it may be refactored using the single responsibility principle.
The next section shows what that refactor might look like.

## Multiple Components

Here are three components that also meet the requirements.
With this architecture, we have one component (`App`) that composes the smaller
pieces into a working app. The form, the weather display, and the data fetching
are all broken up into smaller pieces that are responsible for their own part.


```jsx App.jsx
import CityForm from './CityForm'
import WeatherResult from './WeatherResult'
import { fetchWeather } from './api'

export default function App() {
  const [weather, setWeather] = useState(null)

  return (
    <div>
      <CityForm onSubmit={async (city) => {
        setWeather(await fetchWeather(city))
      }} />

      <WeatherResult weather={weather} />
    </div>
  )
}

```

```jsx CityForm.jsx
export default function CityForm({ onSubmit }) {
  const [city, setCity] = useState('')

  return (
    <form onSubmit={() => onSubmit(city)}>
      <label>
        City:
        <input
          onChange((event) => {
            setName(event.target.value)
          })
          value={name}
        />
      </label>

      <button type="submit">
        Submit
      </button>
    </form>
  )
}
```

```jsx WeatherResult.jsx
export default function WeatherResult({ weather }) {
  if (weather) {
    return (
      <span>The weather is {weather}</span>
    )
  }
  return null
}
```

```js api.js
export async function fetchWeather(city) {
  const result = await fetch(`getweather?city=${city}`)
  return result.json()
}
```

### This approach is good when

- the requirements will change over time
- you want to write tests for individual pieces
- you want to reuse parts of the code
- you have a decent idea how to structure the code

### New problems

It's important to note the trade-offs we're making with this approach.
Tracing the flow of data through the app is now more difficult! We've got
a couple new problems to work through:

1. passing data down from parent to child components
2. passing data up from child to parent components

Now we need to know how to use props for #1 and callbacks for #2. This overhead
was not present in the single component approach.

